-- 1. Cria a tabela para registrar as movimentações de estoque de filamentos.
CREATE TABLE IF NOT EXISTS movimentacoes_estoque (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    filamento_id UUID NOT NULL REFERENCES filamentos(id) ON DELETE CASCADE,
    quantidade_g INTEGER NOT NULL CHECK (quantidade_g != 0), -- Quantidade que entrou (positiva) ou saiu (negativa)
    novo_valor_kg NUMERIC(10, 2) NOT NULL CHECK (novo_valor_kg >= 0), -- O novo preço de custo do filamento por Kg
    observacao TEXT
);

-- Habilita a segurança em nível de linha (RLS) para a nova tabela
ALTER TABLE movimentacoes_estoque ENABLE ROW LEVEL SECURITY;

-- Permite que usuários autenticados leiam e insiram dados na tabela de movimentações
-- Restrinja mais se necessário (ex: apenas para 'admins')
CREATE POLICY "Permitir acesso total para usuários autenticados"
ON movimentacoes_estoque
FOR ALL
TO authenticated
USING (true);


-- 2. Cria a função de banco de dados para garantir a atomicidade da operação.
CREATE OR REPLACE FUNCTION handle_filament_stock_entry(
    p_filament_id UUID,
    p_quantity_grams INTEGER,
    p_new_price_kg NUMERIC,
    p_observation TEXT
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER -- Executa a função com os privilégios do criador (necessário para atualizar a outra tabela)
AS $$
BEGIN
    -- Insere o registro na tabela de histórico de movimentações
    INSERT INTO public.movimentacoes_estoque(filamento_id, quantidade_g, novo_valor_kg, observacao)
    VALUES (p_filament_id, p_quantity_grams, p_new_price_kg, p_observation);

    -- Atualiza o registro principal do filamento
    -- Soma a quantidade nova à existente e atualiza o preço
    UPDATE public.filamentos
    SET 
        quantidade_estoque_gramas = COALESCE(quantidade_estoque_gramas, 0) + p_quantity_grams,
        preco_por_kg = p_new_price_kg
    WHERE id = p_filament_id;
END;
$$; 