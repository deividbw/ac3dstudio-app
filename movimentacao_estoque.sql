-- 1. Cria a tabela para registrar as movimentações de estoque de filamentos.
CREATE TABLE IF NOT EXISTS estoque_filamentos (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    filamento_id UUID NOT NULL REFERENCES filamentos(id) ON DELETE CASCADE,
    quantidade_g INTEGER NOT NULL CHECK (quantidade_g != 0), -- Quantidade que entrou (positiva) ou saiu (negativa)
    novo_valor_kg NUMERIC(10, 2) NOT NULL CHECK (novo_valor_kg >= 0), -- O novo preço de custo do filamento por Kg
    observacao TEXT
);

-- Habilita a segurança em nível de linha (RLS) para a nova tabela
ALTER TABLE estoque_filamentos ENABLE ROW LEVEL SECURITY;

-- Permite que usuários autenticados leiam e insiram dados na tabela de movimentações
-- Restrinja mais se necessário (ex: apenas para 'admins')
CREATE POLICY "Permitir acesso total para usuários autenticados"
ON estoque_filamentos
FOR ALL
TO authenticated
USING (true);


-- 2. Cria a função de banco de dados para garantir a atomicidade da operação.
CREATE OR REPLACE FUNCTION handle_filament_stock_entry(
    p_filament_id UUID,
    p_quantity_grams INTEGER,
    p_new_price_kg NUMERIC,
    p_observation TEXT DEFAULT NULL
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    current_stock_g INTEGER;
    current_price_kg NUMERIC;
    new_total_stock_g INTEGER;
    new_weighted_price_kg NUMERIC;
BEGIN
    -- 1. Obter o estado atual do estoque para o filamento ANTES da atualização
    SELECT
        COALESCE(f.quantidade_estoque_gramas, 0),
        COALESCE(f.preco_por_kg, 0)
    INTO
        current_stock_g,
        current_price_kg
    FROM public.filamentos f
    WHERE f.id = p_filament_id;

    -- 2. Calcular o novo total de estoque
    new_total_stock_g := current_stock_g + p_quantity_grams;

    -- 3. Calcular o novo preço médio ponderado
    -- Evita divisão por zero se o estoque total for zero ou negativo
    IF new_total_stock_g > 0 THEN
        new_weighted_price_kg := 
            ((current_stock_g * current_price_kg) + (p_quantity_grams * p_new_price_kg)) 
            / new_total_stock_g;
    ELSE
        -- Se o estoque ficar zerado ou negativo, o preço pode ser o último informado ou zerado.
        -- Manter o último preço é uma boa opção se o estoque for ser reposto em breve.
        new_weighted_price_kg := p_new_price_kg;
    END IF;

    -- 4. Inserir o registro na tabela de histórico de movimentações
    INSERT INTO public.estoque_filamentos(filamento_id, quantidade_g, novo_valor_kg, observacao)
    VALUES (p_filament_id, p_quantity_grams, p_new_price_kg, p_observation);

    -- 5. Atualizar o registro principal do filamento com os novos valores calculados
    UPDATE public.filamentos
    SET 
        quantidade_estoque_gramas = new_total_stock_g,
        preco_por_kg = new_weighted_price_kg
    WHERE id = p_filament_id;
END;
$$; 